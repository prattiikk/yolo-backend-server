<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Adaptive Frame Rate Dashcam</title>
  <link rel="stylesheet" href="/style.css">
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      background-color: #f4f4f4;
      padding: 20px;
    }

    h1 { color: #333; }

    #video-container {
      position: relative;
      display: inline-block;
      border-radius: 10px;
      overflow: hidden;
      box-shadow: 0px 4px 10px rgba(0, 0, 0, 0.2);
    }

    video {
      border-radius: 10px;
      border: 3px solid #333;
    }

    #startStream {
      margin-top: 10px;
      padding: 10px 20px;
      font-size: 16px;
      border: none;
      border-radius: 5px;
      background-color: #007BFF;
      color: white;
      cursor: pointer;
      transition: background 0.3s;
    }

    #startStream:hover {
      background-color: #0056b3;
    }

    #status {
      margin-top: 15px;
      font-size: 18px;
      color: #555;
    }

    .location-info {
      margin-top: 10px;
      font-size: 14px;
      color: #666;
      max-width: 640px;
      margin-left: auto;
      margin-right: auto;
      text-align: left;
      background-color: #eee;
      padding: 10px;
      border-radius: 5px;
      display: none;
    }
    
    .speed-info {
      margin-top: 10px;
      font-size: 14px;
      color: #333;
      padding: 5px 10px;
      background-color: #d4edda;
      border-radius: 5px;
      display: inline-block;
      font-weight: bold;
    }

    /* Flash effect when capturing a frame */
    .flash {
      animation: flashEffect 0.2s ease-out;
    }

    @keyframes flashEffect {
      0% { opacity: 0.5; }
      100% { opacity: 1; }
    }
    
    #detectionResults {
      margin-top: 15px;
      padding: 10px;
      background-color: #f8f9fa;
      border-radius: 5px;
      max-width: 640px;
      margin-left: auto;
      margin-right: auto;
      text-align: left;
      display: none;
    }
    
    .detection-info {
      padding: 8px;
      margin-top: 5px;
      border-left: 4px solid #007BFF;
      background-color: #e9f5ff;
    }
    
    .detection-critical {
      border-left-color: #dc3545;
      background-color: #ffe9e9;
    }
    
    .detection-high {
      border-left-color: #fd7e14;
      background-color: #fff3e9;
    }
    
    .detection-medium {
      border-left-color: #ffc107;
      background-color: #fffde9;
    }
    
    .detection-low {
      border-left-color: #28a745;
      background-color: #e9ffe9;
    }
  </style>
</head>
<body>

  <h1>Adaptive Frame Rate Dashcam</h1>
  <div id="video-container">
    <video id="liveVideo" width="640" height="360" autoplay></video>
  </div>
  <br>
  <button id="startStream">Start Dashcam</button>
  <p id="status">Waiting to start...</p>
  <div id="speedDisplay" class="speed-info" style="display: none;">Speed: 0 km/h</div>
  <div id="frameRateDisplay" class="speed-info" style="display: none; margin-left: 10px;">Frame Rate: 0 fps</div>
  <div id="locationInfo" class="location-info"></div>
  
  <div id="detectionResults"></div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    // Cache for location measurements for averaging
    const locationMeasurements = [];
    const MAX_MEASUREMENTS = 10;
    let bestAccuracy = Infinity;
    let bestLocation = null;
    let watchId = null;
    let fastWatchId = null;
    let socket = null;
    
    // Variables for adaptive frame rate
    let currentSpeed = 0; // in m/s
    let frameInterval = null;
    let lastCaptureTime = 0;
    let currentFrameRate = 0.2; // default to 1 frame per 5 seconds (0.2 fps)
    
    // Speed thresholds for frame rate adjustment (in km/h)
    const SPEED_THRESHOLDS = [
      { speed: 5, frameRate: 0.1 },   // Below 5 km/h: 0.1 fps (1 frame every 10 seconds)
      { speed: 30, frameRate: 0.2 },  // 5-30 km/h: 0.2 fps (1 frame every 5 seconds)
      { speed: 60, frameRate: 0.5 },  // 30-60 km/h: 0.5 fps (1 frame every 2 seconds)
      { speed: 100, frameRate: 1 },   // 60-100 km/h: 1 fps (1 frame per second)
      { speed: Infinity, frameRate: 2 } // Above 100 km/h: 2 fps (2 frames per second)
    ];
    
    document.getElementById('startStream').addEventListener('click', () => {
      const liveVideo = document.getElementById('liveVideo');
      const statusText = document.getElementById('status');
      const locationInfo = document.getElementById('locationInfo');
      const speedDisplay = document.getElementById('speedDisplay');
      const frameRateDisplay = document.getElementById('frameRateDisplay');
      const detectionResults = document.getElementById('detectionResults');
      
      locationInfo.style.display = 'block';
      speedDisplay.style.display = 'inline-block';
      frameRateDisplay.style.display = 'inline-block';
      detectionResults.style.display = 'block';
      
      socket = io();
      
      // Start gathering location data immediately
      initializeLocationTracking();
      
      const constraints = { 
        video: { 
          facingMode: "environment", 
          width: { ideal: 640 }, 
          height: { ideal: 360 }
        }
      };

      navigator.mediaDevices.getUserMedia(constraints)
        .then((stream) => {
          console.log('Dashcam stream started');
          liveVideo.srcObject = stream;

          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          canvas.width = 640;
          canvas.height = 360;

          // Instead of a fixed interval, we'll use a dynamic approach
          scheduleNextCapture();
          
          function captureFrame() {
            console.log('Capturing frame...');
            statusText.innerText = "üì∏ Capturing frame...";
            lastCaptureTime = Date.now();

            ctx.drawImage(liveVideo, 0, 0, canvas.width, canvas.height);
            const dataUrl = canvas.toDataURL('image/jpeg', 0.6);

            // Get the current best location
            const locationToSend = getBestAvailableLocation();
            
            console.log('Sending frame with location data:', locationToSend);
            statusText.innerText = "üì§ Sending frame with location...";
            liveVideo.classList.add('flash');

            socket.emit('streamVideo', { 
              imageData: dataUrl, 
              location: locationToSend,
              speed: currentSpeed,
              frameRate: currentFrameRate
            });

            setTimeout(() => {
              const accuracyText = locationToSend ? 
                `${locationToSend.accuracy}m (confidence: ${locationToSend.confidence || 'N/A'})` : 
                "unknown";
              statusText.innerText = `‚úÖ Frame sent with location accuracy: ${accuracyText}`;
              liveVideo.classList.remove('flash');
              
              // Schedule next capture based on current speed
              scheduleNextCapture();
            }, 800);
          }
          
          function scheduleNextCapture() {
            // Calculate delay based on current speed and frame rate
            const delay = 1000 / currentFrameRate;
            
            // Clear any existing scheduled capture
            if (frameInterval) clearTimeout(frameInterval);
            
            // Schedule next capture
            frameInterval = setTimeout(captureFrame, delay);
            console.log(`Next frame scheduled in ${delay}ms (${currentFrameRate} fps)`);
          }

          // Handle detection results
          socket.on('detectionComplete', (result) => {
            console.log('Detection complete:', result);
            
            if (result.success) {
              // Update the detection results display
              const resultHTML = createDetectionResultHTML(result);
              detectionResults.innerHTML = resultHTML;
              
              // Update status message
              statusText.innerText = result.message;
            }
          });

          socket.on('disconnect', () => {
            console.log('Disconnected from server');
            if (frameInterval) clearTimeout(frameInterval);
            statusText.innerText = "üî¥ Disconnected!";
            cleanupLocationServices();
          });

        })
        .catch((error) => {
          console.error('Error accessing camera:', error);
          statusText.innerText = "‚ö†Ô∏è Camera access denied!";
        });

      socket.on('connect_error', (error) => {
        console.error('Socket connection error:', error);
        statusText.innerText = "‚ö†Ô∏è Server connection error!";
      });

      socket.on('error', (error) => {
        console.error('Socket error:', error);
        statusText.innerText = "‚ö†Ô∏è Streaming error: " + error.message;
      });
    });
    
    function createDetectionResultHTML(result) {
      if (result.noDetections) {
        return `<p>No issues detected in this frame.</p>`;
      }
      
      let html = `<h3>Detection Results</h3>`;
      
      // Add counts information
      if (result.data && result.data.counts) {
        const counts = result.data.counts;
        html += `<div class="detection-info">`;
        html += `<strong>Detected ${result.data.totalDetections} issues:</strong><br>`;
        
        for (const [key, value] of Object.entries(counts)) {
          html += `- ${value} ${key}<br>`;
        }
        
        // Add processing time
        if (result.data.processingTime) {
          html += `<br>Processing time: ${result.data.processingTime.toFixed(2)}s`;
        }
        
        html += `</div>`;
      }
      
      return html;
    }

    function initializeLocationTracking() {
      // Start a high-frequency watch for rapid position updates
      startFastLocationWatch();
      
      // Also start a high-accuracy watch (might be slower but more precise)
      startPreciseLocationWatch();
      
      // Use supplementary methods for additional accuracy enhancement
      trySupplementaryLocationMethods();
    }
    
    function startFastLocationWatch() {
      // Fast location updates with moderate accuracy
      const fastOptions = {
        enableHighAccuracy: false,
        timeout: 5000,
        maximumAge: 0
      };
      
      fastWatchId = navigator.geolocation.watchPosition(
        handlePositionUpdate,
        (error) => console.warn('Fast location watch error:', error),
        fastOptions
      );
    }
    
    function startPreciseLocationWatch() {
      // Maximum accuracy location updates (might be slower)
      const preciseOptions = {
        enableHighAccuracy: true,
        timeout: 15000,
        maximumAge: 0
      };
      
      watchId = navigator.geolocation.watchPosition(
        handlePositionUpdate,
        (error) => console.warn('Precise location watch error:', error),
        preciseOptions
      );
    }
    
    function handlePositionUpdate(position) {
      // Process new position data
      const currentLocation = {
        // Basic coordinates
        latitude: position.coords.latitude,
        longitude: position.coords.longitude,
        
        // Precision data
        accuracy: position.coords.accuracy,
        altitude: position.coords.altitude,
        altitudeAccuracy: position.coords.altitudeAccuracy,
        heading: position.coords.heading,
        speed: position.coords.speed,
        
        // Timestamp
        timestamp: position.timestamp,
        
        // Source tracking for internal use
        source: position.coords.accuracy > 20 ? 'fast' : 'precise'
      };
      
      // Update speed if available and update frame rate accordingly
      if (currentLocation.speed !== null && currentLocation.speed !== undefined) {
        updateSpeed(currentLocation.speed);
      }
      
      // Update the location display
      updateLocationInfo(currentLocation);
      
      // Store measurement for averaging/filtering
      addLocationMeasurement(currentLocation);
      
      // Update best location if this one is more accurate
      if (currentLocation.accuracy < bestAccuracy) {
        bestAccuracy = currentLocation.accuracy;
        bestLocation = {...currentLocation};
        bestLocation.confidence = 'high';
        console.log(`New best location accuracy: ${bestAccuracy}m`);
      }
    }
    
    function updateSpeed(speedInMps) {
      // Update current speed (convert from m/s to km/h for display)
      currentSpeed = speedInMps;
      const speedInKmh = speedInMps * 3.6;
      
      // Update display
      const speedDisplay = document.getElementById('speedDisplay');
      speedDisplay.textContent = `Speed: ${speedInKmh.toFixed(1)} km/h`;
      
      // Update frame rate based on speed thresholds
      updateFrameRate(speedInKmh);
    }
    
    function updateFrameRate(speedInKmh) {
      // Find appropriate frame rate for current speed
      let newFrameRate = SPEED_THRESHOLDS[0].frameRate; // Default to lowest
      
      for (const threshold of SPEED_THRESHOLDS) {
        if (speedInKmh <= threshold.speed) {
          newFrameRate = threshold.frameRate;
          break;
        }
      }
      
      // Only update if frame rate changed
      if (newFrameRate !== currentFrameRate) {
        currentFrameRate = newFrameRate;
        console.log(`Speed: ${speedInKmh.toFixed(1)} km/h - Frame rate adjusted to ${currentFrameRate} fps`);
        
        // Update display
        const frameRateDisplay = document.getElementById('frameRateDisplay');
        frameRateDisplay.textContent = `Frame Rate: ${currentFrameRate.toFixed(1)} fps`;
      }
    }
    
    function addLocationMeasurement(location) {
      // Add to the measurement cache
      locationMeasurements.push(location);
      
      // Keep only the most recent measurements
      if (locationMeasurements.length > MAX_MEASUREMENTS) {
        locationMeasurements.shift();
      }
    }
    
    function getBestAvailableLocation() {
      // First try to get a filtered/averaged high-precision location
      const filteredLocation = getFilteredLocation();
      
      if (filteredLocation) {
        return filteredLocation;
      }
      
      // Fall back to best single measurement if we have one
      if (bestLocation) {
        return bestLocation;
      }
      
      // Last resort - most recent measurement regardless of quality
      if (locationMeasurements.length > 0) {
        const lastLocation = {...locationMeasurements[locationMeasurements.length - 1]};
        lastLocation.confidence = 'low';
        return lastLocation;
      }
      
      return null; // No location data available
    }
    
    function getFilteredLocation() {
      if (locationMeasurements.length < 3) return null;
      
      // Filter out low-quality measurements
      const goodMeasurements = locationMeasurements.filter(
        loc => loc.accuracy && loc.accuracy < 50
      );
      
      if (goodMeasurements.length < 3) return null;
      
      // Use recent measurements that are relatively consistent
      const recentGoodMeasurements = goodMeasurements.slice(-5);
      
      // Calculate average position
      const sum = recentGoodMeasurements.reduce(
        (acc, loc) => {
          acc.latSum += loc.latitude;
          acc.lngSum += loc.longitude;
          // Weight measurements by inverse of accuracy (more accurate = higher weight)
          acc.weight += 1 / Math.max(loc.accuracy, 1);
          return acc;
        }, 
        { latSum: 0, lngSum: 0, weight: 0 }
      );
      
      // Create weighted average location
      const avgLocation = {
        latitude: sum.latSum / recentGoodMeasurements.length,
        longitude: sum.lngSum / recentGoodMeasurements.length,
        
        // Average additional data from good measurements
        altitude: calculateAverage(recentGoodMeasurements, 'altitude'),
        heading: calculateAverage(recentGoodMeasurements, 'heading'),
        speed: calculateAverage(recentGoodMeasurements, 'speed'),
        
        // Use the best accuracy from the set
        accuracy: Math.min(...recentGoodMeasurements.map(loc => loc.accuracy)),
        
        // Use latest timestamp
        timestamp: Math.max(...recentGoodMeasurements.map(loc => loc.timestamp)),
        
        // Mark as filtered data
        source: 'filtered',
        confidence: 'medium',
        
        // Include satellite data if available
        satelliteData: getSatelliteInfo()
      };
      
      return avgLocation;
    }
    
    function calculateAverage(locations, property) {
      const validValues = locations
        .map(loc => loc[property])
        .filter(value => value !== null && value !== undefined);
      
      if (validValues.length === 0) return null;
      
      return validValues.reduce((sum, val) => sum + val, 0) / validValues.length;
    }
    
    function trySupplementaryLocationMethods() {
      // Try to access device orientation for improved heading
      if (window.DeviceOrientationEvent) {
        window.addEventListener('deviceorientation', handleOrientation);
      }
      
      // Try to access device motion for additional data
      if (window.DeviceMotionEvent) {
        window.addEventListener('devicemotion', handleMotion);
      }
      
      // Try IP-based geolocation as a fallback or supplement
      fetch('https://ipapi.co/json/')
        .then(response => response.json())
        .then(data => {
          console.log('IP geolocation data:', data);
          // Store as fallback
          if (data.latitude && data.longitude) {
            if (locationMeasurements.length === 0) {
              addLocationMeasurement({
                latitude: data.latitude,
                longitude: data.longitude,
                accuracy: 5000, // IP geolocation is typically low accuracy
                source: 'ip',
                confidence: 'very-low',
                timestamp: Date.now()
              });
            }
          }
        })
        .catch(err => console.warn('IP geolocation failed:', err));
    }
    
    // Device orientation handling
    let deviceOrientation = null;
    function handleOrientation(event) {
      deviceOrientation = {
        alpha: event.alpha, // compass direction (0-360)
        beta: event.beta,   // front-to-back tilt
        gamma: event.gamma  // left-to-right tilt
      };
    }
    
    // Device motion handling
    let deviceMotion = null;
    function handleMotion(event) {
      deviceMotion = {
        acceleration: event.acceleration,
        rotationRate: event.rotationRate,
        interval: event.interval
      };
    }
    
    // Get satellite info if available (not directly accessible in most browsers)
    function getSatelliteInfo() {
      // This is a placeholder - browsers don't provide direct satellite info
      // But we could return anything that might be available in future
      return null;
    }
    
    function updateLocationInfo(location) {
      const locationInfo = document.getElementById('locationInfo');
      locationInfo.innerHTML = `
        <strong>Current Location Data:</strong><br>
        Latitude: ${location.latitude.toFixed(6)}<br>
        Longitude: ${location.longitude.toFixed(6)}<br>
        Accuracy: ${location.accuracy ? location.accuracy.toFixed(1) + 'm' : 'Unknown'}<br>
        Source: ${location.source || 'Standard'}<br>
        Time: ${new Date(location.timestamp).toLocaleTimeString()}<br>
        ${location.altitude ? 'Altitude: ' + location.altitude.toFixed(1) + 'm<br>' : ''}
        ${location.heading ? 'Heading: ' + location.heading.toFixed(1) + '¬∞<br>' : ''}
        ${location.speed ? 'Speed: ' + (location.speed * 3.6).toFixed(1) + ' km/h<br>' : ''}
      `;
    }
    
    function cleanupLocationServices() {
      // Clean up all location services
      if (watchId !== null) {
        navigator.geolocation.clearWatch(watchId);
        watchId = null;
      }
      
      if (fastWatchId !== null) {
        navigator.geolocation.clearWatch(fastWatchId);
        fastWatchId = null;
      }
      
      // Clear frame capture interval
      if (frameInterval) {
        clearTimeout(frameInterval);
        frameInterval = null;
      }
      
      // Remove event listeners
      window.removeEventListener('deviceorientation', handleOrientation);
      window.removeEventListener('devicemotion', handleMotion);
    }
    
    // Clean up when page is closed
    window.addEventListener('beforeunload', cleanupLocationServices);
  </script>
</body>
</html>